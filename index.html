<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIMI Ranking Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'gemini-blue': '#1A73E8',
                        'gemini-light': '#E8F0FE',
                        'interquartile': '#34A853', /* This is the green used for success */
                        'outlier-red': '#EA4335',
                        'adjustment-purple': '#8E44AD',
                        'normalization-orange': '#F29900'
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #f8fafc;
            font-family: 'Inter', sans-serif;
        }
        .card {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: box-shadow 0.3s ease-in-out;
        }
        .card-highlight {
            box-shadow: 0 0 0 4px rgb(52, 211, 153), 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .code-output {
            background-color: #1e293b;
            color: #f1f5f9;
            word-break: break-all;
        }
        .adjusted-list {
            background-color: #ffffff;
            border: 1px solid #d1d5db;
            padding: 1rem;
            border-radius: 0.5rem;
            min-height: 100px;
        }
        .adjusted-item-lower {
            color: #1D4ED8;
        }
        .adjusted-item-upper {
            color: #B91C1C;
        }
        
        /* --- Switch Styles (Final) --- */
        .switch {
            position: relative;
            display: inline-block;
            width: 70px; 
            height: 28px; 
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #fca5a5; /* Red for Max-Min */
            transition: .4s;
            border-radius: 28px; 
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 24px; /* Knob height */
            width: 30px; /* Knob width */
            left: 2px; /* Inset from left/bottom */
            bottom: 2px; 
            background-color: white;
            transition: .4s;
            border-radius: 24px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); 
        }

        input:checked + .slider {
            background-color: #86efac; /* Green for Min-Max */
        }

        input:checked + .slider:before {
            transform: translateX(36px); 
        }
        
        /* --- Excel-Friendly Table Styles (Final Compact) --- */
        #finalTableOutput {
            cursor: pointer; 
            border: 2px dashed #d1d5db;
            padding: 1rem;
            border-radius: 0.5rem;
            transition: border-color 0.15s ease-in-out;
        }
        #finalTableOutput:hover {
            border-color: #1A73E8;
        }
        
        #finalTableOutput table {
            width: 100%;
            border-collapse: collapse;
        }
        #finalTableOutput th {
            border: 1px solid #e5e7eb;
            padding: 6px 3px; /* Reduced padding for compactness */
            text-align: right;
            background-color: #eef2ff; 
            font-weight: 600;
            color: #1f2937;
            font-size: 0.75rem; /* Reduced font size for compactness */
            white-space: nowrap; 
        }
        
        /* Smaller font size for ALL table data cells (td) */
        #finalTableOutput td {
            border: 1px solid #e5e7eb;
            padding: 3px 6px; /* Reduced padding for compactness */
            text-align: right;
            font-size: 0.8rem; 
        }

        #finalTableOutput td:first-child, #finalTableOutput td:nth-child(2) {
            text-align: right;
            font-family: monospace;
        }
        
        /* Toast Message Styles */
        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        .toast {
            background-color: rgba(50, 50, 50, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            transform: translateY(20px);
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-blue-700">
                CIMI Ranking Calculator
            </h1>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="bg-white p-6 rounded-xl card lg:col-span-1">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Input Data & Settings</h2>
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Normalization Type</label>
                    <div class="flex items-center space-x-4">
                        <label class="switch">
                            <input type="checkbox" id="normalizationSwitch" checked>
                            <span class="slider"></span>
                            </label>
                        <span id="switchLabel" class="text-sm font-semibold text-interquartile">Min-Max Normalization</span>
                    </div>
                </div>
                
                <textarea 
                    id="dataInput" 
                    rows="5" 
                    placeholder="Enter your numbers here, separated by spaces, commas, or newlines. E.g., 88, 92, 95, 105, 5, 208"
                    class="w-full p-3 border-2 border-gray-300 rounded-lg focus:border-gemini-blue focus:ring-gemini-blue transition duration-150"
                >88, 92, 95, 98, 101, 105, 107, 109, 110, 5, 200, 208, 215, 220, 1</textarea>
                
                <div class="flex space-x-4 mt-4"> <button 
                        id="calculateBtn" 
                        onclick="calculateOutliersAndNormalize()"
                        class="w-3/4 bg-gemini-blue text-white font-bold py-3 rounded-lg hover:bg-blue-700 transition duration-150"
                    >
                        Process All Steps
                    </button>
                    <button 
                        id="clearBtn" 
                        onclick="clearAll()"
                        class="w-1/4 bg-gray-500 text-white font-bold py-3 rounded-lg hover:bg-gray-700 transition duration-150"
                    >
                        Clear All
                    </button>
                </div>
            </div>

            <div class="lg:col-span-2 space-y-8">
                
                <div id="finalTableCard" class="bg-white p-6 rounded-xl card">
                    <h2 class="text-2xl font-semibold text-normalization-orange mb-4"> Final Normalized and Ranked Data</h2>
                    <div id="finalTableOutput">
                        <p class="text-gray-500 italic">The final table will appear here.</p>
                    </div>
                </div>

                <div id="resultsDisplay" class="bg-white p-6 rounded-xl card">
                    <h2 class="text-2xl font-semibold text-gray-700 mb-4">2. Summary & Detected Outliers</h2>
                    <p class="text-gray-500 italic">Press 'Process All Steps' to see the results.</p>
                </div>

                <div id="adjustmentDisplay" class="bg-white p-6 rounded-xl card">
                    <h2 class="text-2xl font-semibold text-adjustment-purple mb-4">3. Outlier Adjusted Values</h2>
                    <p class="text-gray-500 italic">The adjusted values will appear here.</p>
                </div>
            </div>
        </div>
        
        <section class="mt-12 p-6 bg-white rounded-xl card">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">Explanations of Methods</h2>
                <h3 class="text-xl font-medium text-gray-700 mb-2">Type 8 Quantile Definition (Hyndman and Fan, 1996)</h3>
            
              <h3 class="text-sm font-medium text-gray-700 mb-2">Formula for Index <span class="font-mono text-gemini-blue">h</span>:</h3>
            <div class="bg-gray-100 p-4 rounded-lg font-mono text-lg text-center">
                <span class="font-mono font-bold text-gemini-blue">h</span> = p &times; (<span class="font-mono font-bold text-gemini-blue">n</span> + 1/3) + 1/3
            </div>

            <p class="text-sm text-gray-600 mt-2">
                Where:
                <ul class="list-disc list-inside ml-4 mt-2 text-gray-600 space-y-1 text-sm">
                    <li><strong class="font-mono">p</strong> is the probability (e.g., 0.25 for Q1, 0.75 for Q3).</li>
                    <li><strong class="font-mono">n</strong> is the number of data points.</li>
                    <li><strong class="font-mono text-gray-800">h</strong> is the continuous index. The quantile is found by interpolating between the value at index <code class="font-mono text-blue-600">i = floor(h)</code> and the value at index <code class="font-mono text-blue-600">i+1</code>, using the fractional part <code class="font-mono text-blue-600">g = h - i</code>.</li>
                </ul>
            </p>
            
            <p class="text-sm text-gray-600 mt-2">
                This type is recommended for median unbiased estimation when the distribution is heavy-tailed.
            </p>
                
            <h3 class="text-xl font-medium text-interquartile mb-2 mt-6">Min-Max Normalization (Scaling)</h3>
            <div class="bg-gray-100 p-4 rounded-lg font-mono text-lg text-center">
                Score = (Value - Min) / (Max - Min)
            </div>
            <p class="text-sm text-gray-600 mt-2">
                This is the standard normalization method, scaling all adjusted data points to a range between 0 and 1. Higher values in the original data result in higher normalized scores (i.e., higher is better).
            </p>

            <h3 class="text-xl font-medium text-outlier-red mb-2 mt-6">Max-Min Normalization (Inverse Scaling)</h3>
            <div class="bg-gray-100 p-4 rounded-lg font-mono text-lg text-center">
                Score = (Value - Max) / (Min - Max)
            </div>
            <p class="text-sm text-gray-600 mt-2">
                This variation is functionally equivalent to the standard Min-Max but is structured to invert the scaling effect. It's often used when lower values in the original data should result in higher normalized scores (i.e., lower is better), such as when scoring expenses or error rates.
            </p>
        </section>
        
        <section class="mt-8 p-6 bg-white rounded-xl card">
            <h3 class="text-lg font-semibold text-gray-700 mb-2">Citation</h3>
            <p class="text-sm text-gray-600">
                Hyndman, R. J., & Fan, Y. (1996). Sample quantiles in statistical packages. <span style="font-style: italic;">The American Statistician, 50</span>(4), 361-365.  
                <a href="https://doi.org/10.1080/00031305.1996.10473566" class="text-gemini-blue hover:underline" target="_blank">https://doi.org/10.1080/00031305.1996.10473566</a>
            </p>
        </section>

        <footer class="mt-8 text-center text-sm text-gray-700">
            First Created: October 27, 2025 | <span class="text-blue-700">Last Updated: October 28, 2025</span>
        </footer>

    </div>
    
    <div id="toast-container"></div>

    <script>
        const PRECISION = 15;
        const ONE_THIRD = 1/3;

        // --- Core Type 8 Quantile Functions ---
        function quantileType8(data, p) {
            const n = data.length;
            if (n === 0) return NaN;
            
            const h = p * (n + ONE_THIRD) + ONE_THIRD;
            
            const i = Math.floor(h); 
            const g = h - i;       

            const index_i = i - 1; 

            if (h <= 1) return data[0]; 
            if (i >= n) return data[n - 1]; 

            const x_i = data[index_i];
            const x_i_plus_1 = data[index_i + 1];

            return x_i + g * (x_i_plus_1 - x_i);
        }

        function parseInput(input) {
            const cleaned = input.replace(/[,;\n\t]/g, ' ').replace(/\s+/g, ' ').trim();
            if (!cleaned) return [];

            const numbers = cleaned.split(' ').map(Number).filter(n => isFinite(n));
            return numbers.filter(n => !isNaN(n)); 
        }

        function formatNumber(num) {
            let s = num.toFixed(PRECISION);
            s = s.replace(/0+$/, ''); 
            s = s.replace(/\.$/, '');
            return s;
        }
        
        // --- Outlier Adjustment Logic ---
        function adjustOutliers(originalOutliers, fence, quartile, isUpper) {
            const N = originalOutliers.length;
            if (N === 0) return {};
            
            const adjustedValues = {};
            const Distance = Math.abs(fence - quartile);

            // The most extreme outlier adjusts exactly to the fence
            const mostExtremeOutlier = isUpper ? originalOutliers[N - 1] : originalOutliers[0];
            adjustedValues[mostExtremeOutlier] = fence;

            // The remaining N-1 outliers are proportionally distributed
            for (let k = 1; k < N; k++) {
                let originalValue;
                let adjustedValue;
                const factor = k; 

                if (isUpper) {
                    originalValue = originalOutliers[k - 1]; 
                    adjustedValue = quartile + (factor / N) * Distance;
                } else {
                    originalValue = originalOutliers[k]; 
                    adjustedValue = fence + (factor / N) * Distance;
                }

                adjustedValues[originalValue] = adjustedValue;
            }
            
            return adjustedValues;
        }

        // --- Normalization Function ---
        function normalize(value, min, max, isMinMax) {
            if (min === max) {
                return 0.5;
            }
            
            if (isMinMax) {
                return (value - min) / (max - min);
            } else {
                return (value - max) / (min - max);
            }
        }
        
        // --- Toast Notification Function ---
        function showToast(message, duration = 2000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => {
                    container.removeChild(toast);
                }, { once: true });
            }, duration);
        }

        // --- Utility for Copying Table to Clipboard (FIXED: No extra trailing newline) ---
        function copyTableToClipboard(event) {
            if (event) {
                event.stopPropagation();
            }
            
            const table = document.querySelector('#finalTableOutput table');
            if (!table) return;

            const excelRows = []; // Use an array to manage newlines correctly

            // Get Rows (ONLY the tbody content, skipping the headers)
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                // Map innerText to get the data, join by tab for Excel/Sheets
                const rowData = Array.from(cells).map(td => td.innerText).join('\t');
                excelRows.push(rowData); // Push the row data string
            });
            
            // Join the array elements with a newline character, which ensures 
            // no trailing newline is added after the last row.
            const excelData = excelRows.join('\n'); 

            // Robust Copy Mechanism (using a temporary textarea)
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = excelData;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            
            let success = false;
            try {
                success = document.execCommand('copy');
            } catch (err) {
                console.error('Copy attempt failed:', err);
            }
            
            document.body.removeChild(tempTextarea);

            if (success) {
                showToast('✅ Full table data (all 4 columns) copied to clipboard! Paste into Excel/Sheets.');
            } else {
                navigator.clipboard.writeText(excelData).then(() => {
                     showToast('✅ Full table data copied to clipboard (Clipboard API Fallback).');
                }).catch(err => {
                    console.error('Final fallback failed:', err);
                    showToast('❌ Copy failed. Please try manual copy.');
                });
            }
        }
        
        // --- Clear All Function (New) ---
        function clearAll() {
            // Remove the click listener from the old table before clearing the HTML
            const finalTableCard = document.getElementById('finalTableOutput');
            finalTableCard.removeEventListener('click', copyTableToClipboard);

            // 1. Clear Input Data
            document.getElementById('dataInput').value = '';

            // 2. Reset Display Areas
            document.getElementById('finalTableOutput').innerHTML = '<p class="text-gray-500 italic">The final table will appear here.</p>';
            document.getElementById('resultsDisplay').innerHTML = "<p class='text-gray-500 italic'>Press 'Process All Steps' to see the results.</p>";
            document.getElementById('adjustmentDisplay').innerHTML = '<p class="text-gray-500 italic">The adjusted values will appear here.</p>';

            // 3. Show confirmation toast
            showToast('All input and results cleared.');
        }

        // --- Combined Main Function ---
        function calculateOutliersAndNormalize() {
            const inputElement = document.getElementById('dataInput');
            const resultsElement = document.getElementById('resultsDisplay');
            const adjustmentElement = document.getElementById('adjustmentDisplay');
            const finalTableElement = document.getElementById('finalTableOutput');
            const normalizationSwitch = document.getElementById('normalizationSwitch');
            const isMinMax = normalizationSwitch.checked;
            
            const rawInput = inputElement.value;
            
            // 1. Parse Data
            const originalData = parseInput(rawInput);
            if (originalData.length < 4) {
                resultsElement.innerHTML = `<p class="text-outlier-red font-semibold">Error: Need at least 4 data points (n=${originalData.length}).</p>`;
                adjustmentElement.innerHTML = `<p class="text-gray-500 italic">Cannot process due to insufficient data.</p>`;
                finalTableElement.innerHTML = `<p class="text-gray-500 italic">Cannot process due to insufficient data.</p>`;
                return;
            }
            // Need sorted data for quantile calculation
            const sortedData = [...originalData].sort((a, b) => a - b);

            // 2. Calculate Outliers and Adjustment Map
            const Q1 = quantileType8(sortedData, 0.25);
            const Q3 = quantileType8(sortedData, 0.75);
            const IQR_value = Q3 - Q1;
            const k_value = 1.5;
            const lowerFence = Q1 - (k_value * IQR_value);
            const upperFence = Q3 + (k_value * IQR_value);

            const upperOutliers = sortedData.filter(n => n > upperFence);
            const lowerOutliers = sortedData.filter(n => n < lowerFence);
            const allOutliers = [...lowerOutliers, ...upperOutliers];
            
            const adjustedMap = {};
            if (lowerOutliers.length > 0) {
                Object.assign(adjustedMap, adjustOutliers(lowerOutliers, lowerFence, Q1, false));
            }
            if (upperOutliers.length > 0) {
                Object.assign(adjustedMap, adjustOutliers(upperOutliers, upperFence, Q3, true));
            }

            // 3. Generate Adjusted Data List (for ALL data points)
            const adjustedData = originalData.map(val => adjustedMap[val] !== undefined ? adjustedMap[val] : val);
            
            // 4. Calculate Min/Max of the Adjusted Data
            const minAdjusted = adjustedData.length > 0 ? Math.min(...adjustedData) : 0;
            const maxAdjusted = adjustedData.length > 0 ? Math.max(...adjustedData) : 0;
            
            // 5. Normalize and create the final structured data (ALL data points)
            const finalData = adjustedData.map((adjustedVal, index) => {
                const normalizedScore = normalize(adjustedVal, minAdjusted, maxAdjusted, isMinMax);
                return {
                    original: originalData[index],
                    adjusted: adjustedVal,
                    normalized: normalizedScore
                };
            });

            // 6. Calculate Rank (Ranking is applied to ALL data points)
            const rankedData = [...finalData].sort((a, b) => b.normalized - a.normalized);

            let currentRank = 1;
            for (let i = 0; i < rankedData.length; i++) {
                if (i > 0 && rankedData[i].normalized < rankedData[i-1].normalized) {
                    currentRank = i + 1;
                }
                finalData.filter(item => item.normalized === rankedData[i].normalized)
                        .forEach(item => {
                            if (item.rank === undefined) { 
                                item.rank = currentRank;
                            }
                        });
            }
            
            // --- Step 7: Generate Display HTML for Outlier & Adjustment (Section 2 & 3) ---
            
            const outlierListHtml = allOutliers.length > 0
                ? `<div class="code-output p-3 rounded-lg overflow-x-auto text-sm">
                       <span class="font-mono">${allOutliers.map(formatNumber).join(', ')}</span>
                   </div>`
                : `<p class="text-interquartile font-semibold">No outliers found outside the 1.5 &times; IQR range.</p>`;

            resultsElement.innerHTML = `
                <div class="space-y-3">
                    <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <p class="font-bold text-lg text-gray-800 mb-2">Summary Statistics (Type 8 Quantile)</p>
                        <div class="flex flex-wrap gap-4 text-sm">
                            <span class="font-mono bg-gemini-light text-gemini-blue px-2 py-1 rounded">Q1: ${formatNumber(Q1)}</span>
                            <span class="font-mono bg-gemini-light text-interquartile px-2 py-1 rounded">IQR: ${formatNumber(IQR_value)}</span>
                            <span class="font-mono bg-gemini-light text-gemini-blue px-2 py-1 rounded">Q3: ${formatNumber(Q3)}</span>
                        </div>
                    </div>

                    <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                        <p class="font-bold text-lg text-gray-800 mb-2">Outlier Fences (k=1.5)</p>
                        <p class="text-sm text-gray-700 mb-2">Values outside this range are considered outliers (1.5 &times; IQR):</p>
                        <div class="flex flex-col sm:flex-row gap-2 sm:gap-4 text-sm">
                            <span class="font-mono bg-yellow-100 text-yellow-800 px-2 py-1 rounded">Lower Fence: ${formatNumber(lowerFence)}</span>
                            <span class="font-mono bg-yellow-100 text-yellow-800 px-2 py-1 rounded">Upper Fence: ${formatNumber(upperFence)}</span>
                        </div>
                    </div>

                    <div>
                        <p class="font-bold text-xl text-outlier-red mb-2">Total Outliers Detected (${allOutliers.length} found):</p>
                        ${outlierListHtml}
                    </div>
                </div>
            `;
            
            const adjustedLowerList = lowerOutliers.map(o => ({ original: o, adjusted: adjustedMap[o] }));
            const adjustedUpperList = upperOutliers.map(o => ({ original: o, adjusted: adjustedMap[o] }));

            const lowerListHtml = adjustedLowerList.length > 0
                ? `<ul class="space-y-2 text-sm adjusted-list">
                       ${adjustedLowerList.map(item => `
                           <li class="font-mono adjusted-item-lower">
                               ${formatNumber(item.original)} &rarr; <span class="font-bold">${formatNumber(item.adjusted)}</span>
                           </li>
                       `).join('')}
                   </ul>`
                : `<p class="text-gray-500 text-sm p-4">No outliers found below the Lower Fence.</p>`;

            const upperListHtml = adjustedUpperList.length > 0
                ? `<ul class="space-y-2 text-sm adjusted-list">
                       ${adjustedUpperList.map(item => `
                           <li class="font-mono adjusted-item-upper">
                               ${formatNumber(item.original)} &rarr; <span class="font-bold">${formatNumber(item.adjusted)}</span>
                           </li>
                       `).join('')}
                   </ul>`
                : `<p class="text-gray-500 text-sm p-4">No outliers found above the Upper Fence.</p>`;

            let adjustmentMessage = `<p class="text-gray-700 mb-4">The following values were adjusted based on the specified Quartile-to-Fence proportional rule:</p>`;
            if (allOutliers.length === 0) {
                 adjustmentMessage = `<p class="text-gray-700 mb-4">No outliers were detected, so no values were adjusted.</p>`;
            }

            adjustmentElement.innerHTML = `
                ${adjustmentMessage}
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-bold text-base text-blue-700 mb-2 whitespace-nowrap">Adjustments Below Lower Fence (${adjustedLowerList.length} items)</h3>
                        ${lowerListHtml}
                    </div>
                    <div>
                        <h3 class="font-bold text-base text-red-700 mb-2 whitespace-nowrap">Adjustments Above Upper Fence (${adjustedUpperList.length} items)</h3>
                        ${upperListHtml}
                    </div>
                </div>
            `;


            // --- Step 8: Generate Final Table HTML (Section 1) ---
            const normalizationName = isMinMax ? 'Min-Max' : 'Max-Min';
            
            // Generate rows for ALL data points, but only show the original value if it was an outlier
            const tableRows = finalData.map(item => {
                const isOutlier = adjustedMap[item.original] !== undefined;
                // Only show the original value if it was detected as an outlier. Otherwise, leave the cell blank.
                const originalValueCell = isOutlier ? formatNumber(item.original) : '';

                return `
                    <tr>
                        <td ${isOutlier ? 'class="font-bold text-outlier-red"' : ''}>${originalValueCell}</td>
                        <td ${isOutlier ? 'class="font-bold text-adjustment-purple"' : ''}>${formatNumber(item.adjusted)}</td>
                        <td>${formatNumber(item.normalized)}</td>
                        <td>${item.rank}</td>
                    </tr>
                `;
            }).join('');

            // Temporarily disable the event handler to prevent duplicates during update
            const finalTableCard = document.getElementById('finalTableOutput');
            finalTableCard.removeEventListener('click', copyTableToClipboard);
            
            finalTableCard.innerHTML = `
                <div class="mb-4 bg-blue-50 border-l-4 border-blue-400 p-4 text-blue-800 font-semibold">
                    💡 <span class="underline">Click anywhere in this box</span> to automatically copy the <strong class="text-red-600">full table data</strong> (Excel-friendly format).
                </div>
                <div class="mb-4 flex items-center justify-start">
                    <p class="text-sm text-gray-700">Normalization Method Used: <strong class="text-normalization-orange">${normalizationName}</strong>. Min/Max of adjusted data used for scaling.</p>
                </div>
                <div class="overflow-x-auto">
                    <table>
                        <thead>
                            <tr>
                                <th>Outlier Value Only</th>
                                <th>Adjusted Value (Outliers Replaced)</th>
                                <th>${normalizationName} Normalized Score (0 to 1)</th>
                                <th>Rank (Highest Score = 1)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Re-enable the event handler after the innerHTML is set
            finalTableCard.addEventListener('click', copyTableToClipboard);


            // Add a quick visual pulse to draw attention to the new results
            [document.getElementById('finalTableCard'), resultsElement, adjustmentElement].forEach(el => {
                el.classList.add('card-highlight');
                setTimeout(() => {
                    el.classList.remove('card-highlight');
                }, 500);
            });
        }
        
        // --- Switch/Label Handler ---
        document.addEventListener('DOMContentLoaded', () => {
            const normalizationSwitch = document.getElementById('normalizationSwitch');
            const switchLabel = document.getElementById('switchLabel');
            
            function updateSwitchLabel() {
                if (normalizationSwitch.checked) {
                    switchLabel.textContent = 'Min-Max Normalization (Higher is Better)';
                    switchLabel.classList.remove('text-outlier-red');
                    switchLabel.classList.add('text-interquartile');
                } else {
                    switchLabel.textContent = 'Max-Min Normalization (Lower is Better)';
                    switchLabel.classList.remove('text-interquartile');
                    switchLabel.classList.add('text-outlier-red');
                }
                // Call the main function to re-calculate and re-render the table
                calculateOutliersAndNormalize();
            }
            
            updateSwitchLabel();
            normalizationSwitch.addEventListener('change', updateSwitchLabel);
            
            // Also call the main function on initial load
            calculateOutliersAndNormalize();
        });
    </script>
</body>
</html>